The ultimate API toolkit for Python developers.
- Generate SQLAlchemy Models and Marshmallow schemas
- Generate API endpoint controllers with the option to include default implementations based on your models/schemas.
- Customize how the files are generated (naming, location)
- Define

The goal is for anyone to be able to go from OpenAPI 3.0 spec --> working API immediately.  
Include your mechanic.json/.yaml file in your Git repo, and incorporate it into your build process.

# mechanicfile reference

##### APP_NAME
**Required**: No  
**Default value**: "app"  
Option to name your application, this value is used for defining the default logger (among others)

##### OPENAPI
**Required**: Yes  
**Default value**: None  
Path to the OpenAPI 3.0 file to generate from. Example "v100.yaml" or "~/v100.yaml"

##### MICROSERVICE_ROOT_DIR

##### MODELS_PATH 
**Required**: No  
**Default value**: models/{{namespace}}.py   
Defines the path in which to generate SQLAlchemy models. Optional variables are:
- {{namespace}} --> The namespace associated with the model. See [namespaces](#namespaces) for more details.  
- {{version}} --> The OpenAPI 3.0 version defined in the "info" section. Characters not appropriate for python packages 
will be removed, such as dots and dashes. For example, if {{version}} == "1.0.0", the folder name will be "100".

##### MODELS_NAME_PATTERN
**Required**: No  
**Default value**: {{resource}}Model  
Defines how model classes should be named. Optional variables are:
- {{resource}} --> The resource defined in the OpenAPI 3.0 file.
- {{namespace}} --> The namespace associated with the schema. See [namespaces](#namespaces) for more details.   
- {{version}} --> The OpenAPI 3.0 version defined in the "info" section (without dots or dashes)

##### SCHEMAS_NAME_PATTERN
**Required**: No  
**Default value**: {{resource}}Schema  
Defines how schema classes should be named. Optional variables are:
- {{resource}} --> The resource defined in the OpenAPI 3.0 file.
- {{namespace}} --> The namespace associated with the schema. See [namespaces](#namespaces) for more details.   
- {{version}} --> The OpenAPI 3.0 version defined in the "info" section (without dots or dashes)

##### CONTROLLERS_NAME_PATTERN
**Required**: No  
**Default value**: {{resource}}{{controller_type}}Controller  
Defines how controller classes should be named. Optional variables are:
- {{resource}} --> The resource defined in the OpenAPI 3.0 file.
- {{namespace}} --> The namespace associated with the schema. See [namespaces](#namespaces) for more details.   
- {{version}} --> The OpenAPI 3.0 version defined in the "info" section (without dots or dashes)
- {{controller_type}} --> For more details about different controller types, see [controllers](#controllers).

##### SCHEMAS_PATH 
**Required**: No  
**Default value**: schemas/{{namespace}}.py   
Defines the path in which to generate Marshmallow schemas. Optional variables are:
- {{namespace}} --> The namespace associated with the schema. See [namespaces](#namespaces) for more details.   
- {{version}} --> The OpenAPI 3.0 version defined in the "info" section. Characters not appropriate for python packages 
will be removed, such as dots and dashes. For example, if {{version}} == "1.0.0", the folder name will be "100".

##### CONTROLLERS_PATH 
**Required**: No  
**Default value**: controllers/{{namespace}}.py   
Defines the path in which to generate controllers. Optional variables are:
- {{namespace}} --> The namespace associated with the schema. See [namespaces](#namespaces) for more details.   
- {{version}} --> The OpenAPI 3.0 version defined in the "info" section. Characters not appropriate for python packages 
will be removed, such as dots and dashes. For example, if {{version}} == "1.0.0", the folder name will be "100".

##### BASE_API_PATH
**Required**: No  
**Default value**: /api  
Allows you to define the base api path for your REST API.

##### BASE_ITEM_CONTROLLER
**Required**: No  
**Default value**: "mechanic.base.controllers.BaseItemController"  
Allows you to define your own base item controller instead of the one generated by mechanic. For more 
details about different controller types, see [controllers](#controllers).

##### BASE_COLLECTION_CONTROLLER
**Required**: No  
**Default value**: "mechanic.base.controllers.BaseCollectionController"  
Allows you to define your own base collection controller instead of the one generated by mechanic. For more 
details about different controller types, see [controllers](#controllers).

##### BASE_CONTROLLER
**Required**: No  
**Default value**: "mechanic.base.controllers.BaseController"    
Allows you to define your own base controller instead of the one generated by mechanic. For more 
details about different controller types, see [controllers](#controllers).

##### DEFAULT_NAMESPACE
**Required**: No  
**Default value**: "default"  
Allows you to define the default namespace if the "x-mechanic-namespace" extension is not used. For more details about
extensions, see [here](#extensions) for more details.

##### INCLUDE
**Required**: No  
**Default value**: None
Allows you to customize which additional pieces of code to generate. Options are:    

| value                     | description |
| ---                       | --- |
| "application run"         | generates a basic <project-root>/\_\_init\_\_.py file that has app initialization code, and a <project-root>/run.py file, for running the flask app. |
| "controller impl"         | points each controller to the default base controller (unless overridden) and adds the fields needed for the default implementation. |
| "version scheme"          | assumes you want to use the mechanic default versioning scheme. See [versioning](#versioning) for more details. |
 
##### OVERRIDE_BASE_CONTROLLER
**Required**: No  
**Default value**: None  
Allows finer grained control over which controllers inherit from which class. For example, let's say you've defined 
BASE_CONTROLLER as "controllers.base.MyCustomBaseController", but you want only a specific file to inherit instead from 
"controllers.base.MySpecificBaseController". You would use this attribute to define that. Here are some examples:  

This means that "HouseController" will have "MyCustomBaseController" as it's super class, 
instead of the value defined by BASE_CONTROLLER
```json
"OVERRIDE_BASE_CONTROLLER": {
    "with": "controllers.base.MyCustomBaseController",
    "for": "controllers.default.HouseController"
}
```

This example means that all Controllers will inherit from "MyCustomBaseController".
```json
"OVERRIDE_BASE_CONTROLLER": {
    "with": "controllers.base.MyCustomBaseController",
    "for": "all"
}
```

This example means that all Controllers except "HouseController" and "ParkController" will inherit from "MyCustomBaseController".
```json
"OVERRIDE_BASE_CONTROLLER": {
    "with": "controllers.base.MyCustomBaseController",
    "for": "all",
    "except": ["controllers.default.HouseController", "controllers.default.ParkController"]
}
```

##### OVERRIDE_BASE_MODEL
**Required**: No  
**Default value**: None  
Same as [OVERRIDE_BASE_CONTROLLER](#override-base-controller) except for models

##### OVERRIDE_BASE_SCHEMA
**Required**: No  
**Default value**: None  
Same as [OVERRIDE_BASE_CONTROLLER](#override-base-controller) except for schemas

##### OVERRIDE_TABLE_NAME
##### OVERRIDE_DB_SCHEMA_NAME
